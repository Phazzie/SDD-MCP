/**
 * SDD MCP Server - Tool Registry Integration Example
 * Example demonstrating how to use the new ToolRegistry and LegacyToolAdapter.
 * 
 * ðŸŽ¯ CRITICAL: Tool Registry Seam Usage Example
 * Blueprint: Shows how to migrate from legacy tools to modular registry
 * 
 * Generated by: Gemini AI (Phase 2 Implementation)
 * Integrated by: GitHub Copilot
 */

import { ToolRegistry } from "../../src/tool-registry.js";
import { createLegacyToolAdapter } from "../../src/adapters/legacy-tool-adapter.js";
import { ContractResult, ToolModuleContract, ToolDefinition, InvalidInputError } from "../../src/contracts.js";

// Blueprint: Mock the structure of an existing legacy tool before refactor.
// This represents what you'd find in src/tools/*.ts currently.
interface MockLegacyToolStructure {
  definition: {
    name: string;
    description: string;
    inputSchema: any;
    outputSchema: any;
  };
  handler: (args: any) => Promise<ContractResult<any>>;
}

// Blueprint: Create a mock legacy tool instance.
const mockLegacyTool: MockLegacyToolStructure = {
  definition: {
    name: "analyze-data-flows-tool", // Example using a name from the task assignment
    description: "Analyzes data flows in the system (Legacy Mock).",
    inputSchema: { type: "object", properties: { data: { type: "string" } }, required: ["data"] },
    outputSchema: { type: "object", properties: { analysis: { type: "string" } } },
  },
  handler: async (args: any): Promise<ContractResult<any>> => {
    try {
      // Blueprint: Simulate legacy tool's input validation and logic
      if (!args || typeof args.data !== 'string') {
        console.error("Legacy Mock: Invalid input received.");
        return { success: false, error: "Invalid input: 'data' must be a string." };
      }
      console.log(`Legacy Mock Handler received data: "${args.data}"`);
      // Simulate some processing
      const analysisResult = `Analysis of "${args.data}": Data flow looks good (simulated).`;
      return { success: true, data: { analysis: analysisResult } };
    } catch (error: any) {
      // In a real legacy tool, this might not use the new errorHandler
      console.error("Legacy Mock Handler Error:", error);
      return { success: false, error: error.message };
    }
  }
};

// Blueprint: Mock a new tool module conforming to the new contract.
const mockNewToolModule: ToolModuleContract = {
  definition: {
    name: "generate-report-tool",
    description: "Generates a system report (New Module).",
    inputSchema: { type: "object", properties: { type: { type: "string", enum: ["summary", "detail"] } }, required: ["type"] },
    outputSchema: { type: "object", properties: { report: { type: "string" } } },
  },
  handler: async (args: any): Promise<ContractResult<any>> => {
    try {
      // Blueprint: New tool module's input validation using SDD pattern
      if (!args || (args.type !== 'summary' && args.type !== 'detail')) {
        const error = new InvalidInputError("Invalid input: 'type' must be 'summary' or 'detail'.", { args });
        // Assuming errorHandler is available in the new tool module context
        // await errorHandler.logError(error, { context: 'generate-report-tool.handler' });
        return { success: false, error: error.message, metadata: { errorCode: error.errorCode } };
      }
      console.log(`New Tool Handler received type: "${args.type}"`);
      const reportContent = `Generated ${args.type} report (simulated).`;
      return { success: true, data: { report: reportContent } };
    } catch (error: any) {
      // Assuming errorHandler is available
      // await errorHandler.logError(error, { context: 'generate-report-tool.handler', args });
      return { success: false, error: error.message };
    }
  },
  metadata: {
    name: "generate-report-tool",
    version: "1.1.0",
    author: "Gemini",
    tags: ["reporting"]
  }
};

// Blueprint: Demonstrate the integration
export async function demonstrateToolRegistry() {
  console.log("--- Demonstrating Tool Registry Integration ---");

  // 1. Instantiate the registry
  const registry = new ToolRegistry();
  console.log("ToolRegistry instantiated.");

  // 2. Register a new tool module
  console.log("\nRegistering new tool module...");
  const registerNewResult = await registry.registerTool(mockNewToolModule);
  if (registerNewResult.success) {
    console.log("New tool module registered successfully.");
  } else {
    console.error("Failed to register new tool module:", registerNewResult.error);
  }

  // 3. Register a legacy tool using the adapter
  console.log("\nRegistering legacy tool using adapter...");
  const legacyAdapter = createLegacyToolAdapter(mockLegacyTool);
  const registerLegacyResult = await registry.registerTool(legacyAdapter);
  if (registerLegacyResult.success) {
    console.log("Legacy tool registered successfully via adapter.");
  } else {
    console.error("Failed to register legacy tool:", registerLegacyResult.error);
  }

  // 4. Get list of registered tools
  console.log("\nGetting list of registered tools...");
  const getToolsResult = await registry.getTools();
  if (getToolsResult.success && getToolsResult.data) {
    console.log("Registered tools:", getToolsResult.data.map(tool => tool.name));
  } else {
    console.error("Failed to get tools:", getToolsResult.error);
  }

  // 5. Execute a new tool
  console.log("\nExecuting new tool 'generate-report-tool'...");
  const executeNewResult = await registry.executeTool("generate-report-tool", { type: "summary" });
  if (executeNewResult.success) {
    console.log("New tool execution successful:", executeNewResult.data);
  } else {
    console.error("New tool execution failed:", executeNewResult.error);
  }

  // 6. Execute the legacy tool
  console.log("\nExecuting legacy tool 'analyze-data-flows-tool'...");
  const executeLegacyResult = await registry.executeTool("analyze-data-flows-tool", { data: "some important data" });
  if (executeLegacyResult.success) {
    console.log("Legacy tool execution successful:", executeLegacyResult.data);
  } else {
    console.error("Legacy tool execution failed:", executeLegacyResult.error);
  }

  // 7. Demonstrate error handling (e.g., executing non-existent tool)
  console.log("\nAttempting to execute non-existent tool 'non-existent-tool'...");
  const executeNonExistentResult = await registry.executeTool("non-existent-tool", {});
  if (!executeNonExistentResult.success) {
    console.log("Execution of non-existent tool failed as expected:", executeNonExistentResult.error);
  } else {
    console.error("Execution of non-existent tool unexpectedly succeeded!");
  }

  // 8. Demonstrate error handling (e.g., executing tool with invalid input)
  console.log("\nAttempting to execute 'generate-report-tool' with invalid input...");
  const executeInvalidInputResult = await registry.executeTool("generate-report-tool", { type: "invalid" });
  if (!executeInvalidInputResult.success) {
    console.log("Execution with invalid input failed as expected:", executeInvalidInputResult.error);
  } else {
    console.error("Execution with invalid input unexpectedly succeeded!");
  }

  console.log("\n--- Demonstration Complete ---");
  return registry;
}

// Blueprint: Run the demonstration function.
// In the actual index.ts integration, this logic would be part of the server setup.
// demonstrateToolRegistry().catch(console.error);
// Note: To run this example, you would need a TypeScript environment set up
// and potentially mock implementations of any foundation components (like ErrorHandler)
// if they are not yet fully implemented.
