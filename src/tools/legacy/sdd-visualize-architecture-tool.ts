// =============================================================================
// SDD MCP Server - Visualize Architecture Tool (SDD-Compliant)
// =============================================================================
// Clean rewrite using proven SDD template pattern
// Blueprint: Generate Mermaid diagrams showing seam connections

import {
  ArchitectureVisualizationInput,
  ArchitectureVisualizationOutput,
  ContractResult,
  SeamDefinition,
} from "../../contracts.js";

/**
 * SDD Tool: Visualize Architecture
 * Purpose: Generate Mermaid diagrams showing seam connections with color-coded implementation status
 *
 * Blueprint: Create visual representation of seam architecture
 * - Parse seam definitions
 * - Generate Mermaid diagram syntax
 * - Color-code by implementation status
 * - Provide textual component summary
 */
export class SddVisualizeArchitectureTool {
  /**
   * Generate architecture visualization
   * @param input - Seam definitions and project info
   * @returns Mermaid diagram and component analysis
   */
  async execute(
    input: ArchitectureVisualizationInput
  ): Promise<ContractResult<ArchitectureVisualizationOutput>> {
    // Blueprint: SDD Pattern - Fail fast on invalid input
    if (!input) {
      return {
        success: false,
        error: "ArchitectureVisualizationInput is required - failing fast",
      };
    }

    if (!input.seams || !Array.isArray(input.seams)) {
      return {
        success: false,
        error: "Valid seams array is required - failing fast",
      };
    }

    if (!input.projectName) {
      return {
        success: false,
        error: "Project name is required - failing fast",
      };
    }

    try {
      // Blueprint: Core logic - generate Mermaid diagram
      const mermaidDiagram = this.generateMermaidDiagram(
        input.seams,
        input.projectName
      );

      // Blueprint: Generate textual description
      const textualDescription = this.generateTextualDescription(
        input.seams,
        input.projectName
      );

      // Blueprint: Create component summary
      const componentSummary = this.generateComponentSummary(input.seams);

      return {
        success: true,
        data: {
          mermaidDiagram,
          textualDescription,
          componentSummary,
        },
      };
    } catch (error) {
      // Blueprint: SDD Pattern - Structured error handling
      return {
        success: false,
        error: `Architecture visualization failed: ${
          error instanceof Error ? error.message : String(error)
        }`,
        metadata: {
          tool: "SddVisualizeArchitectureTool",
          input: {
            seamCount: input.seams.length,
            projectName: input.projectName,
          },
        },
      };
    }
  }

  /**
   * Generate Mermaid diagram syntax
   * Blueprint: Create visual seam connections with status colors
   */
  private generateMermaidDiagram(
    seams: SeamDefinition[],
    projectName: string
  ): string {
    // Blueprint: Start with graph declaration
    let diagram = `graph TB\n`;
    diagram += `    %% ${projectName} - Seam Architecture\n`;
    diagram += `    %% Generated by SDD Visualize Architecture Tool\n\n`; // Blueprint: Extract unique components
    const components = new Set<string>();
    seams.forEach((seam) => {
      seam.participants.forEach((participant: string) =>
        components.add(participant)
      );
    });

    // Blueprint: Define component nodes with styling
    components.forEach((component) => {
      diagram += `    ${this.sanitizeNodeId(component)}["${component}"]\n`;
    });

    diagram += `\n`;

    // Blueprint: Add seam connections with status colors
    seams.forEach((seam) => {
      const participants = seam.participants;
      if (participants.length >= 2) {
        const source = this.sanitizeNodeId(participants[0]);
        const target = this.sanitizeNodeId(participants[1]);
        const status = seam.status || "stub";
        const styleClass = this.getStatusStyle(status);

        // Blueprint: Create bidirectional or unidirectional arrows
        if (seam.dataFlow === "BOTH") {
          diagram += `    ${source} <--> ${target}\n`;
        } else if (seam.dataFlow === "OUT") {
          diagram += `    ${source} --> ${target}\n`;
        } else {
          diagram += `    ${target} --> ${source}\n`;
        }

        // Blueprint: Add seam label
        diagram += `    ${source} -.->|"${seam.name}"| ${target}\n`;
      }
    });

    // Blueprint: Add styling definitions
    diagram += `\n    %% Styling\n`;
    diagram += `    classDef stub fill:#ffcccc,stroke:#ff6666,stroke-width:2px\n`;
    diagram += `    classDef partial fill:#ffffcc,stroke:#ffcc00,stroke-width:2px\n`;
    diagram += `    classDef complete fill:#ccffcc,stroke:#66cc66,stroke-width:2px\n`;

    return diagram;
  }

  /**
   * Generate textual description of architecture
   * Blueprint: Human-readable seam summary
   */
  private generateTextualDescription(
    seams: SeamDefinition[],
    projectName: string
  ): string {
    let description = `${projectName} Architecture Overview\n`;
    description += `${"=".repeat(50)}\n\n`;

    description += `Total Seams: ${seams.length}\n\n`;

    description += `Seam Details:\n`;
    seams.forEach((seam, index) => {
      description += `${index + 1}. ${seam.name}\n`;
      description += `   Purpose: ${seam.purpose}\n`;
      description += `   Participants: ${seam.participants.join(" â†” ")}\n`;
      description += `   Data Flow: ${seam.dataFlow}\n`;
      description += `   Status: ${seam.status || "stub"}\n`;
      if (seam.description) {
        description += `   Description: ${seam.description}\n`;
      }
      description += `\n`;
    });

    return description;
  }

  /**
   * Generate component connection summary
   * Blueprint: Analyze component connectivity and status
   */
  private generateComponentSummary(
    seams: SeamDefinition[]
  ): { name: string; connections: number; status: string }[] {
    const componentMap = new Map<
      string,
      { connections: number; statuses: string[] }
    >(); // Blueprint: Count connections per component
    seams.forEach((seam) => {
      seam.participants.forEach((participant: string) => {
        if (!componentMap.has(participant)) {
          componentMap.set(participant, { connections: 0, statuses: [] });
        }
        const component = componentMap.get(participant)!;
        component.connections++;
        component.statuses.push(seam.status || "stub");
      });
    });

    // Blueprint: Convert to summary format
    return Array.from(componentMap.entries())
      .map(([name, data]) => ({
        name,
        connections: data.connections,
        status: this.determineOverallStatus(data.statuses),
      }))
      .sort((a, b) => b.connections - a.connections); // Sort by connection count
  }

  /**
   * Sanitize node IDs for Mermaid compatibility
   * Blueprint: Ensure valid Mermaid syntax
   */
  private sanitizeNodeId(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, "_");
  }

  /**
   * Get CSS class for seam status
   * Blueprint: Map status to visual styling
   */
  private getStatusStyle(status: string): string {
    switch (status) {
      case "complete":
        return "complete";
      case "partial":
        return "partial";
      default:
        return "stub";
    }
  }

  /**
   * Determine overall component status from seam statuses
   * Blueprint: Aggregate status logic
   */
  private determineOverallStatus(statuses: string[]): string {
    if (statuses.every((s) => s === "complete")) return "complete";
    if (statuses.some((s) => s === "complete" || s === "partial"))
      return "partial";
    return "stub";
  }
}

// Blueprint: Export for seam integration
export const sddVisualizeArchitectureTool = new SddVisualizeArchitectureTool();
